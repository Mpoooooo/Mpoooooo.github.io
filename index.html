<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="magic zero">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="magic zero">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="magic zero">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> magic zero </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">magic zero</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/Redis数据结构之对象/" itemprop="url">
                  Redis数据结构之对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-02T16:01:26+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>redis在实现键值对数据库的过程，并没有直接使用底层的数据结构，而是基于这些底层的数据结构创建了对象系统，这个系统包括字符串对象、列表对象、hash对象、集合对象和有序集合对象。通过这五种不同类型的对象，redis在执行命令之前，会根据对象类型进行相应的判定和处理；</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来保存数据库中的键和值，每当redis建立一个键值对的时候需要生成两个对象，键对象和值对象。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    unsigned type:4;    //类型</span><br><span class="line">    unsigned encoding:4;    //编码</span><br><span class="line">    unsigned *ptr;    //指向底层实现的数据结构的指针</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>
<p>对象type记录了对象的类型，这个数据的值可以是下面表中类型的一种。<br><img src="/images/redis05-01.png" width="300" height="1000"><br>对象的encoding记录了对象的底层实现，这个属性的值可以是下面表中类型的一种。<br><img src="/images/redis05-02.png" width="600" height="1000"></p>
<h2 id="几种对象的构成"><a href="#几种对象的构成" class="headerlink" title="几种对象的构成"></a>几种对象的构成</h2><img src="/images/redis05-03.png" width="600" height="1000">
<img src="/images/redis05-04.png" width="600" height="1000">
<img src="/images/redis05-05.png" width="600" height="1000">
<img src="/images/redis05-06.png" width="600" height="1000">
<img src="/images/redis05-07.png" width="600" height="1000">
<img src="/images/redis05-08.png" width="600" height="1000">
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>因为C语言不具备自动的内存回收机制，所以redis在自己的对象系统中构建了引用计数计数来实现内存的回收，通过这一个机制，程序可以通过跟踪对象的计数信息，在适当的时候进行相应的内存回收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    //...</span><br><span class="line">    int refcount; //初始化为1，使用+1，释放-1</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象的引用计数属性还带有对象共享的作用。Redis会共享值为0到9999的字符串对象。如果键A创建了一个包含整数值100的字符串对象作为值对象，键B也要创建一个同样保存了整数值100的字符串对象作为值对象，服务器可以让键Ａ和键B共享同一个字符串对象，Redis中需要两步：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。共享对象机制对于节约内存非常有帮助，数据库中保存的相同值对象越多，对象共享机制就能节约越多的内存。</li>
</ol>
<img src="/images/redis05-09.png" width="600" height="1000">
<p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同。一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多。</p>
<p>如果共享对象是保存整数值的字符串对象，验证操作的复杂度O（1）</p>
<p>如果共享对象是保存字符串值的字符串对象，验证操作的复杂度O（N）</p>
<p>如果共享对象是包含多个值（比如列表对象或者哈希对象）对象，验证操作的复杂度O（N2）</p>
<p>故尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值得字符串对象进行共享。</p>
<h2 id="对象的空转"><a href="#对象的空转" class="headerlink" title="对象的空转"></a>对象的空转</h2><p>object除了前面type、encoding、ptr和refcount四个属性之外，还包含一个lru，该属性记录了对象最后被使用的时间，当前时间减去最后被使用的时间，就是该对象的空转时间。<br>键的空转时长主要的作用是：如果服务器打开了maxmemory选项，并且服务器的回收内存算法为volatile-lru或者allkeys-lru，那么，当超过了maxmemory设置的上限时，空转较高的对象会优先被释放内存。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/Redis-数据结构之压缩列表/" itemprop="url">
                  Redis 数据结构之压缩列表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-01T17:03:53+08:00" content="2016-06-01">
              2016-06-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>压缩列表是列表键和hash键的底层实现之一，当一个列表键只包含少量的列表项，并且每个列表项是小整数或是断字符串，就会使用压缩列表来作为底层的实现。</p>
<h2 id="redis压缩列表的构成"><a href="#redis压缩列表的构成" class="headerlink" title="redis压缩列表的构成"></a>redis压缩列表的构成</h2><p>压缩列表是为了节省内存而进行开发的，一个压缩列表可以包含任意多个节点，每一个节点保存一个字节数组或是一个整数值。<br><img src="/images/redis04-01.png" width="600" height="1000"></p>
<ul>
<li>zlbytes:记录整个压缩链表占用的内存字节数，对压缩链表进行内存重新分配，或者计算zlen的时候进行使用；</li>
<li>zltail：记录压缩链表的表尾节点距离表头节点地址有多少字节，通过这个偏移量能够直接定位到表尾节点；</li>
<li>zllen：记录整个压缩链表的节点数目，当其值的大小小于UINT16_MAX的时候，记录的是真实的大小，当值等于UINT16_MAX的时候，需要遍历整个链表才能够计算出来zllen的大小；</li>
<li>entryX:列表的节点</li>
<li>zlend：特殊标记符，用于记录列表的末端</li>
</ul>
<p>下面展示了一个真实的压缩链表实例：</p>
<ul>
<li>zlbytes的属性值为<code>0x50</code>,表示压缩链表的总长为80字节；</li>
<li>zltail的属性值为<code>0x3c</code>，十进制为60，表头指针加上60得到表尾的位置；</li>
<li>zlen的属性值为<code>0x03</code>，有3个节点；<img src="/images/redis04-02.png" width="600" height="1000">
</li>
</ul>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><p>压缩列表由三个部分组成：</p>
<ul>
<li>previous_entry_length:以字节为单位，记录前一个压缩列表的长度，通过这个属性，能够进行列表从尾到头的遍历；</li>
<li>encoding:保存当前节点的类型以及长度；</li>
<li>content：负责保存节点的值，值的属性可以是字节数组或者整数，值的类型和常数由节点的encoding属性决定；<img src="/images/redis04-03.png" width="600" height="1000">
</li>
</ul>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><ul>
<li>由于每个previous_entry_length都记录了前一个节点的长度，如果前一个节点的长度小于254字节，那么该属性需要1字节的空间来保存这个长度；</li>
<li>如果前一个节点的长度大约等于254字节，那么该属性要5字节的空间来保存这个长度；<br>如果一个压缩链表中有多个连续的、长度介于250到253之间的节点，此时在其头部添加一个长度大约254字节的节点后，此时其e1的previous_entry_length有一个字节变成5个字节，同时e1的长度也大于254字节，同时e2也会进行相应的更新，以此类推进行了相应的连锁更新；</li>
</ul>
<img src="/images/redis04-04.png" width="600" height="1000">
<p>同样删除节点也会引起相应的连锁更新，如下图所示。</p>
<img src="/images/redis04-05.png" width="600" height="1000">
<p>虽然连锁更新的复杂度高(重新分配内存最坏时间复杂度为O(n),因此总的连锁更新时间复杂度为O(n^2))，但是需要同时满足大量的连续的长度介于250-253之前节点的情况，出现的概率低。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/28/Redis-数据结构之跳跃表/" itemprop="url">
                  Redis 数据结构之跳跃表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-28T16:59:40+08:00" content="2016-04-28">
              2016-04-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>跳跃表是一种有序的数据结构，通过每个节点中维持多个指向其他节点的指针，从而达到快速访问的目的。其平均复杂度为o(logn),最坏复杂度o(n)进行相应的节点查找。大多数的情况下，跳跃表能够与平衡树相媲美。通常的跳跃表结构如下所示。<br><img src="/images/redis03-01.png" width="600" height="1000"></p>
<h2 id="redis跳跃表的结构"><a href="#redis跳跃表的结构" class="headerlink" title="redis跳跃表的结构"></a>redis跳跃表的结构</h2><p>在redis中，跳跃表的运用并不广泛，主要在两个地方使用跳跃表，一个是实现有序集合键，一个是在集群节点中用作内部数据结构。<br>跳跃表的节点结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<p>跳跃节点的层level数组可以包含多组数据，每次创建一个跳跃表的时候，程序都会根据幂定律（越大的数字出现概率越小）随机生成一个1~32的数字，作为新表节点的层数。<br><img src="/images/redis03-03.png" width="600" height="1000"><br>介绍几个比较重要的概念：</p>
<ul>
<li>每一层都有一个指向表尾的前进指针，方便从表尾开始访问到表头</li>
<li>跨度的操作其实与遍历访问并关系，用跨度是来计算排位的，在查找的过程中，各层访问过的跨度加起来就是节点在跳跃表中的位置</li>
<li>分值和成员，分值是一个double数值，多个节点可以相同，节点按照分值的大小进行排列，但是对象必须是唯一的,分值相同的节点按照对象的顺序进行排序（字典序）。</li>
</ul>
<p>仅需要多个这样的节点就可以排列整一个跳跃表，但是为了便于管理，redis通过一个zskiplist进行对组成的跳跃表进行管理，其具体的数据结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<img src="/images/redis03-02.png" width="600" height="1000">
<p>header指向跳跃表的表头，tail指向表尾，length表示跳跃表节点的数量，level属性则用于记录跳跃表中节点level最大的level值（表头节点不计算在内）。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/28/os开发实战01-第一个img镜像的启动/" itemprop="url">
                  os开发实战01-第一个img镜像的启动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-28T00:17:30+08:00" content="2016-04-28">
              2016-04-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在这个系列中，希望自己能够在看书的过程中，从无到有，开发出一个属于自己的操作系统，同时，能在开发过程中，更加的深入学习这些基础知识，做到融会贯通。</p>
<h2 id="操作系统的启动前"><a href="#操作系统的启动前" class="headerlink" title="操作系统的启动前"></a>操作系统的启动前</h2><p>在操作系统的启动之前，计算机需要尽心一系列的操作，比较关键的节点如下：</p>
<ol>
<li>按下电源开关时，电压不稳，主板上的控制芯片组会向CPU发出并保持一个RESET（重置）信号，让CPU内部自动恢复到初始状态，但CPU在此刻不会马上执行指令。当芯片组检测到电源已经开始稳定供电了，它便撤去RESET信号，CPU马上就从地址FFFF0H处开始执行指令，从前面的介绍可知，这个地址实际上在系统BIOS的地址范围内，无论是Award BIOS还是AMI BIOS，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。 </li>
<li>下面就到了我们熟知的bios阶段，在这个阶段系统首先要进行自检，查看关键设备是否处于正常状态，状态正常的话，我们通常也会听到滴的声响。然后bios会查找显卡的bios，并调用显卡的初始化代码，同时也会查找其他相关设备的初始化代码，并进行相应的初始化。</li>
<li>再完成相关的初始化后，系统会加载bios自己的启动画面，并且bios会检测cpu的频率，并测试所有ram，并咋屏幕显示进度条，并且在内存检查完成后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD－ROM、串口、并口、软驱等设备， 标准设备检测完毕后，系统BIOS内部的支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。</li>
<li>接下来系统BIOS将更新ESCD（Extended System Configuration Data，扩展系统配置数据）。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS（一小块特殊的RAM，由主板上的电池来供电）之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows系统不相同的数据格式，于是Windows在它自己的启动过程中会把ESCD数据修改成自己的格式，但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来，如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。 </li>
<li><p>完成这些任务后，此时系统会让用户选择是从哪里进行启动操作系统。</p>
<h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2></li>
<li><p>系统bios将第一个物理扇区加载到内存，，读取并立即执行第一个扇区的MBR，并将系统的控制权交给MBR</p>
</li>
<li>MBR运行以后，搜索MBR的分区表，查找活动分区的启示位置，并将活动扇区的第一个扇区（分区引导记录）加载到内存，并检测文件系统的可用性。</li>
<li>MBR查找相应的操作系统启动文件（ntldr），把控制权利交给他，由他对操作系统的内核进行相应的加载工作。 </li>
</ol>
<h2 id="自制的操作系统"><a href="#自制的操作系统" class="headerlink" title="自制的操作系统"></a>自制的操作系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">        ORG        0x7c00          ; 指明程序的装载地址</span><br><span class="line"></span><br><span class="line">; 以下这段是标准FAT32格式专用的代码</span><br><span class="line"></span><br><span class="line">        JMP       entry</span><br><span class="line">        DB        0x90</span><br><span class="line">        DB        &quot;HELLO@OS&quot;    ; freeparam 启动区的名称可以是任意的字符串（8字节）</span><br><span class="line">        DW        512              ; 每个扇区（sector）的大小（必须为512字节）</span><br><span class="line">        DB        1                ; 簇（cluster）的大小（必须为1个扇区）</span><br><span class="line">        DW        1                ; FAT的起始位置（一般从第一个扇区开始）</span><br><span class="line">        DB        2                ; FAT的个数（必须为2）</span><br><span class="line">        DW        224              ; 根目录的大小（一般设成224项）</span><br><span class="line">        DW        2880             ; 该磁盘的大小（必须是2880扇区）</span><br><span class="line">        DB        0xf0             ; 磁盘的种类（必须是0xf0）</span><br><span class="line">        DW        9                ; FAT的长度（必须是9扇区）</span><br><span class="line">        DW        18               ; 1个磁道（track）有几个扇区（必须是18）</span><br><span class="line">        DW        2                ; 磁头数（必须是2）</span><br><span class="line">        DD        0                ; 不使用分区，必须是0</span><br><span class="line">        DD        2880             ; 重写一次磁盘大小</span><br><span class="line">        DB        0,0,0x29         ; 意义不明，固定</span><br><span class="line">        DD        0xffffffff       ; （可能是）卷标号码</span><br><span class="line">        DB        &quot;HELLO-OS   &quot;    ; freeparam 磁盘的名称（11字节）</span><br><span class="line">        DB        &quot;FAT12   &quot;       ; 磁盘格式名称（8字节）</span><br><span class="line">        RESB     18                ; 先空出18字节</span><br><span class="line"></span><br><span class="line">; 程序核心</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">        MOV        AX,0            ; 初始化寄存器</span><br><span class="line">        MOV        SS,AX</span><br><span class="line">        MOV        SP,0x7c00</span><br><span class="line">        MOV        DS,AX</span><br><span class="line">        MOV        ES,AX</span><br><span class="line"></span><br><span class="line">        MOV        SI,msg</span><br><span class="line">putloop:</span><br><span class="line">        MOV        AL,[SI]</span><br><span class="line">        ADD        SI,1            ; 给SI加1</span><br><span class="line">        CMP        AL,0</span><br><span class="line">        JE         fin</span><br><span class="line">        MOV        AH,0x0e         ; 显示一个文字</span><br><span class="line">        MOV        BX,15           ; 指定字符颜色</span><br><span class="line">        INT        0x10            ; 调用显卡BIOS</span><br><span class="line">        JMP        putloop</span><br><span class="line">fin:</span><br><span class="line">        HLT                        ; 让CPU停止；等待指令</span><br><span class="line">        JMP        fin             ; 无限循环</span><br><span class="line"></span><br><span class="line">msg: ; 信息显示部分</span><br><span class="line">        DB        0x0a, 0x0a        ; 换行2次</span><br><span class="line">        DB        &quot;hello, mpoooooo&apos;s OS!&quot;    ; freeparam</span><br><span class="line">        DB        0x0a            ; 换行</span><br><span class="line">        DB        0</span><br><span class="line"></span><br><span class="line">        RESB    0x7dfe-$        ; 填写0x00，直到0x001fe</span><br><span class="line"></span><br><span class="line">        DB        0x55, 0xaa</span><br><span class="line"></span><br><span class="line">; 以下是启动区以外部分的输出</span><br><span class="line"></span><br><span class="line">        DB        0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">        RESB    4600</span><br><span class="line">        DB        0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">        RESB    1469432</span><br></pre></td></tr></table></figure>
<img src="/images/os01-01.png" width="400" height="800">
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/26/丐版C语言编译器之虚拟机/" itemprop="url">
                  丐版C语言编译器之虚拟机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-26T16:18:19+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>我们需要自己设计一套汇编解析器，将代码转换成相应的汇编代码，以生成最终的目标代码。</p>
<h2 id="C程序内存布局"><a href="#C程序内存布局" class="headerlink" title="C程序内存布局"></a>C程序内存布局</h2><p>C程序的内存管理主要有一下的几个主要区域，他们分别是：</p>
<ul>
<li>文本段(text segment)：例如CPU执行的机器指令，通常文本段是只读性质的，还有文字常量区，例如字符串常量会放在该段。</li>
<li>简单数据段(initialized data segment)：初始化的全局变量或者初始化的静态变量。</li>
<li>bss段(uninitialized data segment)：未初始化的全局变量等。</li>
<li>栈(stack)：局部变量，以及函数形参等，强调变化。</li>
<li>堆(heap)：动态内存，需要由程序自己处理释放问题。</li>
</ul>
<p>我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。因此我们需要在全局增加如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *text,</span><br><span class="line">    *old_text,</span><br><span class="line">    *stack;</span><br><span class="line">char *data;</span><br></pre></td></tr></table></figure></p>
<p>在main函数中，完成对这三块区域的内存分配，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 寄存器</span><br><span class="line">计算机中的寄存器用于存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用 4 个寄存器，分别如下：</span><br><span class="line"></span><br><span class="line">1. pc计数器，存放一个内存地址，这个地址存放了下个需要执行的指令地址；</span><br><span class="line">2. sp指针计数器，永远指向当前的栈帧顶部；</span><br><span class="line">3. bp基址指针，调用函数的时候用到它； </span><br><span class="line">4. ax通用寄存器，存放一条指令执行后的结果；</span><br><span class="line"></span><br><span class="line">因此，在全局中加入如下的定义：</span><br></pre></td></tr></table></figure></p>
<p>int <em>pc, </em>bp, *sp, ax, cycle; // virtual machine registers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在main函数中，需要对这些变量进行赋值，由于PC在初始应指向目标代码中的main函数，但我们还没有写任何编译相关的代码，因此先不处理。代码如下：</span><br></pre></td></tr></table></figure></p>
<p>```</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/26/丐版C语言编译器之整体框架/" itemprop="url">
                  丐版C语言编译器之整体框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-26T15:31:04+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>整个丐版系列是想跟随着xc.c系列进行一次造轮子学习，希望能够通过这样的一次造轮子，对一些C语言编译相关的知识掌握的更加的了解，我予以命名chaos.xc,更加希望能够在完成丐版系列以后，能对其中的一些模块进行更进一步的改动和提高，不断的能够进行一些优化，也能够支持一些新的特性。</p>
<h2 id="编译器的构建流程"><a href="#编译器的构建流程" class="headerlink" title="编译器的构建流程"></a>编译器的构建流程</h2><p>整个编译器的构建流程分为三个部分，分别是：</p>
<ol>
<li>词法分析，将字符串代码进行切词，编程内部结构。</li>
<li>语法分析，将词法分析得到的标记流（token），生成一个语法树。</li>
<li>目标代码的生成，将语法树变成目标代码。</li>
</ol>
<p>因此在整个丐版编译器的实现过程中，需要构建自己的词法分析和语法分析器，同时，也需要构建自己的虚拟机以及指令集，最终生成的目标代码也是我们的指令集。</p>
<h2 id="编译器框架"><a href="#编译器框架" class="headerlink" title="编译器框架"></a>编译器框架</h2><p>在本篇博客中，简单的对整个chaos.c的框架进行相应的布局，该编译器主要包括四个函数，分别是：</p>
<ol>
<li><code>next()</code>函数，进行相应的词法分析，生成token标记流;</li>
<li><code>program()</code>函数，语法分析函数入口，对传来的代码字符串进行相应的语法分析；</li>
<li><code>expression(level)</code>函数，用于解析一个表达式；</li>
<li><code>eval()</code>函数，虚拟机的入口，用于解释目标代码；</li>
</ol>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

int token;
char *src , *old_src;

//读取代码词
void next(){
    token = *src++;
    return ;
}

void program(){
    next();
    while(token != &apos;\0&apos;){
        printf(&quot;token is: %c\n&quot;, token);
        next();
    }
}

int eval(){
    return 0;
}

int main(int argc, char **argv){
    int i, fd;
    argc --;
    argv ++;
    //读取需要编译的代码文件    
    printf(&quot;the src file is (%s)\n&quot;, *argv); 
    if((fd = open(*argv, O_RDONLY)) &lt; 0){
        printf(&quot;could not open(%s)\n&quot;, *argv);
        return -1;
    }
    //分配代码字符串空间
    int poolsize = 256 * 1024;
    if(!(src = old_src = malloc(poolsize))){
        printf(&quot;could not malloc(%d) for source area\n&quot;, poolsize);
        return -1;
    }
    //将代码复制到该空间中，末尾补0
    if((i = read(fd, src, poolsize - 1)) &lt;= 0){
        printf(&quot;read() returned %d\n&quot;, i);
        return -1;
    }
    src[i] = &apos;\0&apos;;
    close(fd);
    program();
    return eval();
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/Redis数据结构之链表与字典/" itemprop="url">
                  Redis数据结构之链表与字典
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-25T22:42:05+08:00" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>链表提供了高效的节点重排能力，能够通过增删节点灵活的调整链表的长度。<br>字典又称符号表、关联数组或者是映射，是一种能够有效的组织键值对的一种数据结构，在字典中每一个键值都是唯一的，在程序中，通过键值查找到与其相关联的值。redis中使用字典十分普遍，redis数据库的底层就是使用字典实现的，对数据的增删改查构建在对字典的操作，</p>
<h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>在redis中，每一个链表的节点都使用一个<code>adlist.h/listNode</code>结构来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">	struct listNode *prev;</span><br><span class="line">	struct listNode *next;</span><br><span class="line">	void *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></p>
<p>一个一个这样的节点，连接成一个双向链表，在redis中，为了对链表进行更加有效的管理，使用了<code>adlist.h/list</code>来对链表进行管理，其具体的结构如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef list&#123;</span><br><span class="line">	//指向头结点</span><br><span class="line">	listNode *head;</span><br><span class="line">	//指向尾部节点</span><br><span class="line">	listNode *tail;</span><br><span class="line">	//链表的长度</span><br><span class="line">	unsigned long len;</span><br><span class="line">	//用于复制节点所保存的值</span><br><span class="line">	void *(*dup)(void *ptr);</span><br><span class="line">	//用于释放节点所保存的值</span><br><span class="line">	void *(*free)(void *ptr);</span><br><span class="line">	//用于对比节点中所保存的值与新来的值是否相等</span><br><span class="line">	int (*match)(void *ptr, void *key); </span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure></p>
<p>list函数提供了包括头结点、尾节点、以及链表计数器等相关的链表参数，同时，为了能够更好的提供链表服务，list提供了dup、free、match用于多态链表所需类型定制函数。其具体的结构如下图所示。<br><img src="/images/redis02-01.png" width="600" height="800"></p>
<p>对redis实现的list进行一下总结：</p>
<ul>
<li>redis提供的链表是双向无环链表</li>
<li>提供了指向head、tail以及计数器等基本结构</li>
<li>实现了list存储的多态</li>
</ul>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>redis的字典使用了hash表作为底层的实现，一个hash表中存在多个hash节点，每一个hash节点中存在一个键值对。其结构<code>dict.h/dictht</code>如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">	//hash表数组</span><br><span class="line">	dictEntry **table；</span><br><span class="line">	//hash表大小</span><br><span class="line">	unsigned long size；</span><br><span class="line">	//hash大小掩码，用于计算hash值</span><br><span class="line">	unsigned long sizemask；</span><br><span class="line">	//已有节点</span><br><span class="line">	unsigned long used；</span><br><span class="line">&#125;dictht；</span><br></pre></td></tr></table></figure></p>
<img src="/images/redis02-02.png" width="400" height="400">
<p>table是一个数组，每个数组指针都指向了一个dictEntry的结构体，该结构体中，保存了一个键值对。其结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">	void key;</span><br><span class="line">	union value&#123;</span><br><span class="line">		void *val;</span><br><span class="line">		uint64_t u64;</span><br><span class="line">		int32_t s64; </span><br><span class="line">	&#125;</span><br><span class="line">	struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p>
<h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>在redis中，dict的结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line">    int iterators; /* number of iterators currently running */</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>dictType和privdata能够根据不同类型的键值对，进行不同的操作，实现了redis的多态。比如在dictType中，其结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">    //hash键函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    //复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line">    //复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line">    //对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line">    //销毁键的函数</span><br><span class="line">	void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line">    //销毁值的函数</span><br><span class="line">	void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></p>
<p>而ht中，提供了两个hash表，一个是通常使用的hash表，另一个是rehash时需要作为中转的hash表。普通状态下的dict结构如下。<br><img src="/images/redis02-03.png" width="800" height="1000"></p>
<h3 id="hash冲突及解决"><a href="#hash冲突及解决" class="headerlink" title="hash冲突及解决"></a>hash冲突及解决</h3><p>在dict中，进行hash计算的方法使用了murmurHash2（hash值与sizemask进行与计算）。并采用链地址法解决hash冲突问题。<br>随着操作的不断进行，为了让负载因子（used/size）维持在一个合理的范围内，需要对hash表的大小进行相应的调整操作。<br>扩展和收缩都是通过rehash进行的，其相应的执行步骤如下：</p>
<ol>
<li>空间分配，如果是增大，则新表ht[1]的大小为超过ht[0].used * 2的最小2的n次幂；如果是缩小，则ht[1]的大小为大于等于ht[0].used的最小2的n次幂;</li>
<li>将保存的ht[0]中的键值rehash到ht[1]上面；</li>
<li>完成rehash后将ht[1]替换ht[0]，并为ht[1]重新创建一个空表，为下一次做准备。</li>
</ol>
<p>何时进行rehash操作:</p>
<ul>
<li>当服务器没有在执行bgsave命令，或者bgrewriteaof命令，并且hash表的负载因子大于等于1；</li>
<li>当服务器正在执行bgsave命令，或者bgrewriteaof命令，并且hash表的负载因子大于等于5；</li>
</ul>
<p>在执行rehash过程中，为了避免大量的rehash计算，dict的采用了渐进式rehash，分批次的将ht[0]中的值rehash到ht[1]中，并同时在将dict的标记位设置为标记值，在rehash过程中，字典的删除、查找、更新同时在两个表上进行，ht[0]中找不到的话，在ht[1]中进行寻找，而插入操作，直接在ht[1]进行，等到完成rehash后，复位标记位，并将ht[1]替换掉ht[0]。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/Redis数据结构之SDS/" itemprop="url">
                  Redis数据结构之SDS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-25T19:40:16+08:00" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在redis中，没有直接的使用C语言的字符串表示，而是在其基础上，进行了相关的封装，构建了一个简单的动态字符串类型（simple dynamic string），并作为其默认的字符串表示。</p>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>在sds.h中可以看到其结构体如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    //记录buf中使用字节数</span><br><span class="line">    unsigned int len;</span><br><span class="line">    //记录buf中未使用的字节数</span><br><span class="line">    unsigned int free;</span><br><span class="line">    //存储数据buf</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其具体的结构如下如所示，值得注意的是在buf存储的过程中，会在buf的末尾默认加上一个’\0’,这样做的好处是能够直接调用C语言中，对字符串的相关操作。<br><img src="/images/redis01-01.png" width="400" height="600" title="SDS默认内存分布"></p>
<h2 id="SDS的buf内存分配策略"><a href="#SDS的buf内存分配策略" class="headerlink" title="SDS的buf内存分配策略"></a>SDS的buf内存分配策略</h2><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>空间预分配用于优化Sds的空间增长策略，当其对空间进行扩展的时候，程序不仅会为Sds分配buf增长所必须的空间，还会为其分配预留测空间，具体的分配策略如下。</p>
<ul>
<li>如果对Sds修改以后，len的值小于1MB，则同时给free分配和len相同大小的空间，此时，buf总的空间大小为<code>len+free+1</code>。</li>
<li>如果对Sds修改以后，len的值大约1MB，则只给free分配1MB大小的空间，此时buf总空间的大小为<code>len+1MB+1</code>。</li>
</ul>
<h3 id="空间惰性的释放"><a href="#空间惰性的释放" class="headerlink" title="空间惰性的释放"></a>空间惰性的释放</h3><p>该释放用于优化字符串缩短的操作，在buf缩短的过程中，并没有将多出来的空间直接释放掉，而是累加到了free上面，buf总的占用空间并没有减少，具体的空间释放会在需要的时候进行释放。<br><img src="/images/redis01-02.png" width="400" height="600"><br><img src="/images/redis01-03.png" width="400" height="600"></p>
<h2 id="SDS和C语言的区别"><a href="#SDS和C语言的区别" class="headerlink" title="SDS和C语言的区别"></a>SDS和C语言的区别</h2><ol>
<li>首先表现在对字符串的操作上，sds在计算字符串长度是O（1）的时间复杂度，而语言字符串为O（n）。</li>
<li>在使用某些函数的时候，比如strcat、strcpy等操作函数，C语言要先检查分配字符空间，否则容易造成缓冲区溢出，Sds中会先检查free是否够用，不够用则进行内存分配，否则进行相关的buf赋值，避免了缓冲溢出。</li>
<li>避免了内存的频繁分配，C语言中进行字符串长度变化的时候，都要重新为其分配新的内存，否则容易造成内存泄露，而在Sds中，相关的字符串长度变化，都会用free和len字段进行控制，内存的释放统一进行，释放掉free长度的内存。</li>
<li>二进制安全，redis通常会用Sds保存二进制数据（Sds也叫字节数组），buf会直接将所有来的数据直接的拷贝，不进行任何过滤，而C语言中，遇到空格、回车等分隔符会自动进行分割。</li>
<li>能够兼容部分的C语言字符串操作函数。</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-25T19:36:13+08:00" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ava.png"
               alt="mpoooooo" />
          <p class="site-author-name" itemprop="name">mpoooooo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mpoooooo</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
